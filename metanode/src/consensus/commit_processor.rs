// Copyright (c) MetaNode Team
// SPDX-License-Identifier: Apache-2.0

use anyhow::Result;
use consensus_core::{BlockAPI, CommittedSubDag};
use hex;
use mysten_metrics::monitored_mpsc::UnboundedReceiver;
use std::collections::BTreeMap;
use std::sync::atomic::AtomicBool;
use std::sync::Arc;
use std::time::Duration; // [Added] Import Duration
use tokio::time::sleep; // [Added] Import sleep for retry mechanism
use tracing::{error, info, trace, warn};

use crate::consensus::checkpoint::calculate_global_exec_index;
use crate::node::executor_client::ExecutorClient;
use crate::types::tx_hash::calculate_transaction_hash_hex;

/// Commit processor that ensures commits are executed in order
pub struct CommitProcessor {
    receiver: UnboundedReceiver<CommittedSubDag>,
    next_expected_index: u32, // CommitIndex is u32
    pending_commits: BTreeMap<u32, CommittedSubDag>,
    /// Optional callback to notify commit index updates (for epoch transition)
    commit_index_callback: Option<Arc<dyn Fn(u32) + Send + Sync>>,
    /// Optional callback to update global execution index after successful commit
    global_exec_index_callback: Option<Arc<dyn Fn(u64) + Send + Sync>>,
    /// Current epoch (for deterministic global_exec_index calculation)
    current_epoch: u64,
    /// Callback to get current last global execution index
    get_last_global_exec_index: Option<Arc<dyn Fn() -> u64 + Send + Sync>>,
    /// Shared last global exec index for direct updates
    shared_last_global_exec_index: Option<Arc<tokio::sync::Mutex<u64>>>,
    /// Optional executor client to send blocks to Go executor
    executor_client: Option<Arc<ExecutorClient>>,
    /// Flag indicating if epoch transition is in progress
    /// When true, we're transitioning to a new epoch
    is_transitioning: Option<Arc<AtomicBool>>,
    /// Queue for transactions that must be retried in the next epoch
    pending_transactions_queue: Option<Arc<tokio::sync::Mutex<Vec<Vec<u8>>>>>,
    /// Optional callback to handle EndOfEpoch system transactions
    /// Called immediately when an EndOfEpoch system transaction is detected in a committed sub-dag
    /// Uses commit finalization approach (like Sui) - no buffer needed as commits are processed sequentially
    epoch_transition_callback: Option<Arc<dyn Fn(u64, u64, u32) -> Result<()> + Send + Sync>>,
}

impl CommitProcessor {
    pub fn new(receiver: UnboundedReceiver<CommittedSubDag>) -> Self {
        Self {
            receiver,
            next_expected_index: 1, // First commit has index 1 (consensus doesn't create commit with index 0)
            pending_commits: BTreeMap::new(),
            commit_index_callback: None,
            global_exec_index_callback: None,
            get_last_global_exec_index: None,
            shared_last_global_exec_index: None,
            current_epoch: 0,
            executor_client: None,
            is_transitioning: None,
            pending_transactions_queue: None,
            epoch_transition_callback: None,
        }
    }

    /// Set callback to notify commit index updates
    pub fn with_commit_index_callback<F>(mut self, callback: F) -> Self
    where
        F: Fn(u32) + Send + Sync + 'static,
    {
        self.commit_index_callback = Some(Arc::new(callback));
        self
    }

    /// Set callback to update global execution index after successful commit
    pub fn with_global_exec_index_callback<F>(mut self, callback: F) -> Self
    where
        F: Fn(u64) + Send + Sync + 'static,
    {
        self.global_exec_index_callback = Some(Arc::new(callback));
        self
    }

    /// Set callback to get current last global execution index
    pub fn with_get_last_global_exec_index<F>(self, _callback: F) -> Self
    where
        F: Fn() -> u64 + Send + Sync + 'static,
    {
        // Currently not used, but kept for future extensibility
        // CRITICAL: We now read directly from shared_last_global_exec_index instead of callback
        self
    }

    /// Set shared last global exec index for direct updates
    pub fn with_shared_last_global_exec_index(
        mut self,
        shared_index: Arc<tokio::sync::Mutex<u64>>,
    ) -> Self {
        self.shared_last_global_exec_index = Some(shared_index);
        self
    }

    /// Set epoch and last_global_exec_index for deterministic global_exec_index calculation
    pub fn with_epoch_info(mut self, epoch: u64, _last_global_exec_index: u64) -> Self {
        self.current_epoch = epoch;
        // last_global_exec_index is now obtained from shared_last_global_exec_index, no need to store locally
        self
    }

    /// Set executor client to send blocks to Go executor
    pub fn with_executor_client(mut self, executor_client: Arc<ExecutorClient>) -> Self {
        self.executor_client = Some(executor_client);
        self
    }

    /// Set is_transitioning flag to track epoch transition state
    pub fn with_is_transitioning(mut self, is_transitioning: Arc<AtomicBool>) -> Self {
        self.is_transitioning = Some(is_transitioning);
        self
    }

    /// Provide a queue to store transactions that must be retried in the next epoch.
    pub fn with_pending_transactions_queue(
        mut self,
        pending_transactions_queue: Arc<tokio::sync::Mutex<Vec<Vec<u8>>>>,
    ) -> Self {
        self.pending_transactions_queue = Some(pending_transactions_queue);
        self
    }

    /// Set callback to handle EndOfEpoch system transactions
    pub fn with_epoch_transition_callback<F>(mut self, callback: F) -> Self
    where
        F: Fn(u64, u64, u32) -> Result<()> + Send + Sync + 'static,
    {
        self.epoch_transition_callback = Some(Arc::new(callback));
        self
    }

    /// Process commits in order
    pub async fn run(self) -> Result<()> {
        let mut receiver = self.receiver;
        let mut next_expected_index = self.next_expected_index;
        let mut pending_commits = self.pending_commits;
        let commit_index_callback = self.commit_index_callback;
        let current_epoch = self.current_epoch;
        let executor_client = self.executor_client;
        let pending_transactions_queue = self.pending_transactions_queue;
        let epoch_transition_callback = self.epoch_transition_callback;

        // --- [FORK SAFETY FIX] ---
        // Initialize local tracker. We read from shared state ONLY ONCE at startup.
        // This ensures sequential consistency within the loop, preventing race conditions
        // where we might read a stale index from the shared mutex.
        let mut tracked_last_global_exec_index =
            if let Some(ref shared_index) = self.shared_last_global_exec_index {
                let index_guard = shared_index.lock().await;
                *index_guard
            } else {
                // Fallback: try callback if shared index not available
                if let Some(ref callback) = self.get_last_global_exec_index {
                    callback()
                } else {
                    0
                }
            };

        // #region agent log
        {
            use std::io::Write;
            let ts = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap();
            if let Ok(mut f) = std::fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open("/home/abc/chain-n/mtn-simple-2025/.cursor/debug.log")
            {
                let _ = writeln!(
                    f,
                    r#"{{"id":"log_{}_{}","timestamp":{},"location":"commit_processor.rs:124","message":"COMMIT PROCESSOR STARTED","data":{{"current_epoch":{},"last_global_exec_index":{},"next_expected_index":{},"hypothesisId":"A"}},"sessionId":"debug-session","runId":"run1"}}"#,
                    ts.as_secs(),
                    ts.as_nanos() % 1000000,
                    ts.as_millis(),
                    current_epoch,
                    tracked_last_global_exec_index,
                    next_expected_index
                );
            }
        }
        // #endregion

        info!("üöÄ [COMMIT PROCESSOR] Started processing commits for epoch {} (last_global_exec_index={}, next_expected_index={})",
            current_epoch, tracked_last_global_exec_index, next_expected_index);

        let mut last_heartbeat_commit = 0u32;
        let mut last_heartbeat_time = std::time::Instant::now();
        const HEARTBEAT_INTERVAL: u32 = 1000;
        const HEARTBEAT_TIMEOUT_SECS: u64 = 300;

        info!("üì° [COMMIT PROCESSOR] Waiting for commits from consensus...");

        loop {
            match receiver.recv().await {
                Some(subdag) => {
                    let commit_index: u32 = subdag.commit_ref.index;
                    info!("üì• [COMMIT PROCESSOR] Received committed subdag: commit_index={}, leader={:?}, blocks={}",
                        commit_index, subdag.leader, subdag.blocks.len());

                    // Heartbeat logic
                    if commit_index >= last_heartbeat_commit + HEARTBEAT_INTERVAL {
                        let elapsed = last_heartbeat_time.elapsed().as_secs();
                        info!("üíì [COMMIT PROCESSOR HEARTBEAT] Processed {} commits (last {} commits in {}s)", 
                            commit_index, HEARTBEAT_INTERVAL, elapsed);
                        last_heartbeat_commit = commit_index;
                        last_heartbeat_time = std::time::Instant::now();
                    }

                    // Check for stuck processor
                    let time_since_last_heartbeat = last_heartbeat_time.elapsed().as_secs();
                    if time_since_last_heartbeat > HEARTBEAT_TIMEOUT_SECS
                        && commit_index == last_heartbeat_commit
                    {
                        warn!("‚ö†Ô∏è  [COMMIT PROCESSOR] Possible stuck detected: No progress for {}s (last commit: {})", 
                            time_since_last_heartbeat, commit_index);
                    }

                    info!(
                        "üìä [COMMIT CONDITION] Checking commit_index={}, next_expected_index={}",
                        commit_index, next_expected_index
                    );

                    // --- [AUTO-JUMP ON STARTUP] ---
                    // If this is the VERY FIRST commit we receive after restart, and it is > expected,
                    // we assume we are resuming from a higher commit index (provided by reliable Consensus Core).
                    // This avoids reading DB for initial index (which User disallowed).
                    if next_expected_index == 1 && commit_index > 1 {
                        warn!("üöÄ [AUTO-JUMP] Initial commit {} > expected 1. Auto-jumping to match stream.", commit_index);
                        next_expected_index = commit_index;
                    }

                    if commit_index == next_expected_index {
                        // --- [FORK SAFETY IMPLEMENTATION] ---
                        // Use the LOCAL tracker for calculation.
                        // This guarantees deterministic increment: Index(N) = Index(N-1) + Blocks(N-1)
                        let current_last_global_exec_index = tracked_last_global_exec_index;

                        let global_exec_index = calculate_global_exec_index(
                            current_epoch,
                            commit_index,
                            current_last_global_exec_index,
                        );

                        info!("üìä [GLOBAL_EXEC_INDEX] Calculated: global_exec_index={}, epoch={}, commit_index={}, current_last_global_exec_index={}",
                            global_exec_index, current_epoch, commit_index, current_last_global_exec_index);

                        let total_txs_in_commit = subdag
                            .blocks
                            .iter()
                            .map(|b| b.transactions().len())
                            .sum::<usize>();

                        // CRITICAL FIX: Process commit FIRST before triggering epoch transition
                        // This ensures Go receives the EndOfEpoch commit before Rust starts transition
                        Self::process_commit(
                            &subdag,
                            global_exec_index,
                            current_epoch,
                            executor_client.clone(),
                            pending_transactions_queue.clone(),
                            self.shared_last_global_exec_index.clone(),
                        )
                        .await?;

                        // Update local tracker immediately after successful processing.
                        // The next iteration is GUARANTEED to see this updated value.
                        tracked_last_global_exec_index = global_exec_index;

                        if let Some(ref callback) = self.global_exec_index_callback {
                            callback(global_exec_index);
                        }

                        if let Some(ref callback) = commit_index_callback {
                            callback(commit_index);
                        }

                        next_expected_index += 1;

                        // Check for EndOfEpoch system transactions AFTER commit is sent to Go
                        if let Some((_block_ref, system_tx)) =
                            subdag.extract_end_of_epoch_transaction()
                        {
                            if let Some((
                                new_epoch,
                                new_epoch_timestamp_ms,
                                _commit_index_from_tx,
                            )) = system_tx.as_end_of_epoch()
                            {
                                info!(
                                    "üéØ [SYSTEM TX] EndOfEpoch transaction detected in commit {}: epoch {} -> {}, total_txs_in_commit={}",
                                    commit_index, current_epoch, new_epoch, total_txs_in_commit
                                );

                                if let Some(ref callback) = epoch_transition_callback {
                                    info!(
                                        "üöÄ [EPOCH TRANSITION] Triggering epoch transition AFTER commit sent to Go: commit_index={}, new_epoch={}, global_exec_index={}",
                                        commit_index, new_epoch, global_exec_index
                                    );

                                    if let Err(e) =
                                        callback(new_epoch, new_epoch_timestamp_ms, commit_index)
                                    {
                                        warn!("‚ùå Failed to trigger epoch transition from system transaction: {}", e);
                                    }
                                }
                            }
                        }

                        // Process pending out-of-order commits
                        while let Some(pending) = pending_commits.remove(&next_expected_index) {
                            let pending_commit_index = next_expected_index;

                            // Use LOCAL tracker for pending commits as well
                            let current_last_global_exec_index = tracked_last_global_exec_index;

                            let global_exec_index = calculate_global_exec_index(
                                current_epoch,
                                pending_commit_index,
                                current_last_global_exec_index,
                            );

                            Self::process_commit(
                                &pending,
                                global_exec_index,
                                current_epoch,
                                executor_client.clone(),
                                pending_transactions_queue.clone(),
                                self.shared_last_global_exec_index.clone(),
                            )
                            .await?;

                            // Update local tracker
                            tracked_last_global_exec_index = global_exec_index;

                            if let Some(ref callback) = commit_index_callback {
                                callback(pending_commit_index);
                            }

                            next_expected_index += 1;
                        }
                    } else if commit_index > next_expected_index {
                        warn!(
                            "Received out-of-order commit: index={}, expected={}, storing for later",
                            commit_index, next_expected_index
                        );
                        pending_commits.insert(commit_index, subdag);
                    } else {
                        warn!(
                            "Received commit with index {} which is less than expected {}",
                            commit_index, next_expected_index
                        );
                    }
                }
                None => {
                    warn!("‚ö†Ô∏è  [COMMIT PROCESSOR] Commit receiver closed (commit processor will exit).");
                    break;
                }
            }
        }
        Ok(())
    }

    /// Queue all user transactions from a failed commit for processing in the next epoch
    async fn queue_commit_transactions_for_next_epoch(
        subdag: &CommittedSubDag,
        pending_transactions_queue: &Arc<tokio::sync::Mutex<Vec<Vec<u8>>>>,
        commit_index: u32,
        global_exec_index: u64,
        epoch: u64,
    ) {
        let has_end_of_epoch = subdag.extract_end_of_epoch_transaction().is_some();

        let mut queued_count = 0;
        let mut skipped_count = 0;

        for (block_idx, block) in subdag.blocks.iter().enumerate() {
            for (tx_idx, tx) in block.transactions().iter().enumerate() {
                let tx_data = tx.data();

                // Skip EndOfEpoch system transactions - they are epoch-specific
                if has_end_of_epoch && Self::is_end_of_epoch_transaction(tx_data) {
                    info!("‚ÑπÔ∏è  [TX FLOW] Skipping EndOfEpoch system transaction in failed commit {} (epoch-specific, cannot be queued for next epoch)", commit_index);
                    skipped_count += 1;
                    continue;
                }

                // Queue the transaction for next epoch
                let mut queue = pending_transactions_queue.lock().await;
                queue.push(tx_data.to_vec());
                queued_count += 1;

                let tx_hash = crate::types::tx_hash::calculate_transaction_hash(tx_data);
                let tx_hash_hex = hex::encode(&tx_hash[..8]);

                info!("üì¶ [TX FLOW] Queued failed transaction from commit {} block {} tx {}: hash={} (size={})",
                    commit_index, block_idx, tx_idx, tx_hash_hex, tx_data.len());
            }
        }

        if queued_count > 0 {
            info!("‚úÖ [TX FLOW] Queued {} transactions from failed commit {} (global_exec_index={}, epoch={}) for next epoch",
                queued_count, commit_index, global_exec_index, epoch);
        }

        if skipped_count > 0 {
            info!("‚ÑπÔ∏è  [TX FLOW] Skipped {} system transactions from failed commit {} (not suitable for next epoch)",
                skipped_count, commit_index);
        }
    }

    fn is_end_of_epoch_transaction(tx_data: &[u8]) -> bool {
        if tx_data.len() < 10 {
            return false;
        }
        let data_str = String::from_utf8_lossy(tx_data);
        data_str.contains("EndOfEpoch")
            || data_str.contains("epoch") && data_str.contains("transition")
    }

    async fn process_commit(
        subdag: &CommittedSubDag,
        global_exec_index: u64,
        epoch: u64,
        executor_client: Option<Arc<ExecutorClient>>,
        pending_transactions_queue: Option<Arc<tokio::sync::Mutex<Vec<Vec<u8>>>>>,
        shared_last_global_exec_index: Option<Arc<tokio::sync::Mutex<u64>>>,
    ) -> Result<()> {
        let commit_index = subdag.commit_ref.index;
        let mut total_transactions = 0;
        let mut transaction_hashes = Vec::new();
        let mut block_details = Vec::new();

        for (block_idx, block) in subdag.blocks.iter().enumerate() {
            let transactions = block.transactions();
            total_transactions += transactions.len();

            for tx in transactions {
                let tx_data = tx.data();
                let tx_hash_hex = calculate_transaction_hash_hex(tx_data);
                transaction_hashes.push(tx_hash_hex);
            }

            block_details.push(format!(
                "block[{}]={:?} ({}tx)",
                block_idx,
                block.reference(),
                transactions.len()
            ));
        }

        let has_system_tx = subdag.extract_end_of_epoch_transaction().is_some();

        if total_transactions > 0 || has_system_tx {
            info!(
                "üî∑ [Global Index: {}] Executing commit #{} (epoch={}): {} blocks, {} txs, has_system_tx={}",
                global_exec_index, commit_index, epoch, subdag.blocks.len(), total_transactions, has_system_tx
            );

            if let Some(ref client) = executor_client {
                let mut retry_count = 0;
                loop {
                    match client
                        .send_committed_subdag(subdag, epoch, global_exec_index)
                        .await
                    {
                        Ok(_) => {
                            info!("‚úÖ [TX FLOW] Successfully sent committed subdag: global_exec_index={}, commit_index={}",
                                global_exec_index, commit_index);

                            // Update shared last global exec index for monitoring visibility
                            if let Some(shared_index) = shared_last_global_exec_index.clone() {
                                let mut index_guard = shared_index.lock().await;
                                *index_guard = global_exec_index;
                                info!("üìä [GLOBAL_EXEC_INDEX] Updated shared last_global_exec_index to {} after successful send", global_exec_index);
                            }

                            // Track committed transaction hashes to prevent duplicates during epoch transitions
                            // CRITICAL: Only track when commit is actually processed, not just submitted
                            if let Some(node_arc) = crate::node::get_transition_handler_node().await
                            {
                                let node_guard = node_arc.lock().await;
                                let mut hashes_guard =
                                    node_guard.committed_transaction_hashes.lock().await;

                                let mut tracked_count = 0;
                                for block in &subdag.blocks {
                                    for tx in block.transactions() {
                                        let tx_hash =
                                            crate::types::tx_hash::calculate_transaction_hash(
                                                tx.data(),
                                            );
                                        let hash_hex = hex::encode(&tx_hash);

                                        // Special debug logging for the problematic transaction
                                        if hash_hex.starts_with("44a535f2") {
                                            warn!("üîç [DEBUG] Committing problematic transaction {} in commit #{} (global_exec_index={})",
                                                  hash_hex, commit_index, global_exec_index);
                                        }

                                        hashes_guard.insert(tx_hash.clone());
                                        tracked_count += 1;

                                        // Also save to persistent storage for epoch transition recovery
                                        if let Err(e) = crate::node::transition::save_committed_transaction_hash(
                                            &node_guard.storage_path, epoch, &tx_hash
                                        ).await {
                                            warn!("‚ö†Ô∏è [TX TRACKING] Failed to persist committed hash after commit: {}", e);
                                        } else {
                                            trace!("üíæ [TX TRACKING] Persisted committed hash: {} for epoch {}", hash_hex, epoch);
                                        }
                                    }
                                }

                                if tracked_count > 0 {
                                    info!("üíæ [TX TRACKING] Tracked {} committed transaction hashes after processing commit #{} (global_exec_index={})",
                                          tracked_count, commit_index, global_exec_index);
                                }
                            }

                            break;
                        }
                        Err(e) => {
                            // Case 1: Duplicate index - Critical Fork Safety check
                            if e.to_string().contains("Duplicate global_exec_index") {
                                error!("üö® [FORK-SAFETY] Duplicate global_exec_index={} detected! Skipping commit {} to prevent fork. Error: {}", 
                                    global_exec_index, commit_index, e);
                                break;
                            }

                            // Case 2: System Transaction (EndOfEpoch) failed - Retry needed
                            if has_system_tx {
                                retry_count += 1;
                                error!("üö® [CRITICAL] Failed to send commit {} containing EndOfEpoch transaction (Attempt {}). Retrying in 1s... Error: {}", 
                                    commit_index, retry_count, e);

                                sleep(Duration::from_secs(1)).await;
                                continue;
                            }

                            // Case 3: Regular transaction failure
                            warn!("‚ö†Ô∏è  [TX FLOW] Failed to send committed subdag: {}", e);
                            if let Some(ref queue) = pending_transactions_queue {
                                Self::queue_commit_transactions_for_next_epoch(
                                    subdag,
                                    queue,
                                    commit_index,
                                    global_exec_index,
                                    epoch,
                                )
                                .await;
                            } else {
                                warn!("‚ö†Ô∏è  [TX FLOW] No pending_transactions_queue - transactions may be lost!");
                            }
                            break;
                        }
                    }
                }
            } else {
                info!("‚ÑπÔ∏è  [TX FLOW] Executor client not enabled, skipping send");
            }
        } else {
            // Empty commit handling (heartbeat/tick)
            if let Some(ref client) = executor_client {
                match client
                    .send_committed_subdag(subdag, epoch, global_exec_index)
                    .await
                {
                    Ok(_) => {
                        info!("‚úÖ [TX FLOW] Successfully sent empty commit: global_exec_index={}, commit_index={}",
                            global_exec_index, commit_index);

                        if let Some(shared_index) = shared_last_global_exec_index.clone() {
                            let mut index_guard = shared_index.lock().await;
                            *index_guard = global_exec_index;
                            info!("üìä [GLOBAL_EXEC_INDEX] Updated shared last_global_exec_index to {} for empty commit", global_exec_index);
                        }
                    }
                    Err(e) => {
                        if e.to_string().contains("Duplicate global_exec_index") {
                            warn!("üö® [FORK-SAFETY] Duplicate global_exec_index={} detected for empty commit. Skipping.", global_exec_index);
                        } else {
                            warn!("‚ö†Ô∏è  Failed to send empty subdag: {}", e);
                        }
                    }
                }
            }
        }

        Ok(())
    }
}
