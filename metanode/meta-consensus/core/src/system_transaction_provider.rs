// Copyright (c) MetaNode Team
// SPDX-License-Identifier: Apache-2.0

use crate::system_transaction::SystemTransaction;
use consensus_config::Epoch;
use std::sync::{Arc, RwLock};
use tracing::{info, warn};

/// Provider for system transactions (similar to Sui's EndOfEpochTransaction provider)
/// This replaces the Proposal/Vote/Quorum mechanism with system transactions
pub trait SystemTransactionProvider: Send + Sync {
    /// Get system transactions to include in the next block
    /// Returns None if no system transaction should be included
    fn get_system_transactions(&self, current_epoch: Epoch, current_commit_index: u32) -> Option<Vec<SystemTransaction>>;
}

/// Default implementation that checks if epoch transition is needed
pub struct DefaultSystemTransactionProvider {
    /// Current epoch
    current_epoch: Arc<RwLock<Epoch>>,
    /// Epoch duration in seconds
    epoch_duration_seconds: u64,
    /// Epoch start timestamp in milliseconds
    epoch_start_timestamp_ms: Arc<RwLock<u64>>,
    /// Time-based epoch change enabled
    time_based_enabled: bool,
    /// Last commit index where we checked for epoch change
    last_checked_commit_index: Arc<RwLock<u32>>,
    /// Commit index buffer (number of commits to wait after detecting system transaction)
    /// OPTIMIZED: Default reduced to 50 commits for faster epoch transitions (was 100)
    /// With commit rate 200 commits/s, 50 commits = 250ms (faster than 100 commits = 500ms)
    commit_index_buffer: u32,
}

impl DefaultSystemTransactionProvider {
    /// Create a new provider with default buffer (50 commits for faster transition)
    pub fn new(
        current_epoch: Epoch,
        epoch_duration_seconds: u64,
        epoch_start_timestamp_ms: u64,
        time_based_enabled: bool,
    ) -> Self {
        Self::new_with_buffer(
            current_epoch,
            epoch_duration_seconds,
            epoch_start_timestamp_ms,
            time_based_enabled,
            50, // OPTIMIZED: Reduced from 100 to 50 commits for faster epoch transition
        )
    }

    /// Create a new provider with custom commit index buffer
    ///
    /// # Arguments
    /// * `commit_index_buffer` - Number of commits to wait after detecting system transaction
    ///   before triggering epoch transition.
    ///   - For low commit rate (<10 commits/s): 10-20 commits is sufficient
    ///   - For medium commit rate (10-100 commits/s): 20-50 commits recommended
    ///   - For high commit rate (>100 commits/s): 50-100 commits recommended
    ///   - OPTIMIZED: Default reduced from 100 to 50 commits for faster transitions
    ///   - With 200 commits/s, 50 commits = 250ms (faster than 100 commits = 500ms)
    pub fn new_with_buffer(
        current_epoch: Epoch,
        epoch_duration_seconds: u64,
        epoch_start_timestamp_ms: u64,
        time_based_enabled: bool,
        commit_index_buffer: u32,
    ) -> Self {
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
        let elapsed_seconds = (now_ms.saturating_sub(epoch_start_timestamp_ms)) / 1000;
        
        info!(
            "üìÖ SystemTransactionProvider initialized: epoch={}, epoch_start={}ms, now={}ms, elapsed={}s, duration={}s, time_based_enabled={}",
            current_epoch,
            epoch_start_timestamp_ms,
            now_ms,
            elapsed_seconds,
            epoch_duration_seconds,
            time_based_enabled
        );
        
        if time_based_enabled && elapsed_seconds >= epoch_duration_seconds {
            warn!(
                "‚ö†Ô∏è  SystemTransactionProvider: Epoch start timestamp is {}s old (>= duration {}s). System transaction should be created on next leader round.",
                elapsed_seconds,
                epoch_duration_seconds
            );
        }
        
        Self {
            current_epoch: Arc::new(RwLock::new(current_epoch)),
            epoch_duration_seconds,
            epoch_start_timestamp_ms: Arc::new(RwLock::new(epoch_start_timestamp_ms)),
            time_based_enabled,
            last_checked_commit_index: Arc::new(RwLock::new(0)),
            commit_index_buffer,
        }
    }

    /// Update current epoch (called after epoch transition)
    /// FORK-SAFETY: When syncing from Go, prioritize Go's timestamp over local calculation
    /// Only override if timestamp is significantly in the past (consensus delay scenario)
    pub async fn update_epoch(&self, new_epoch: Epoch, new_timestamp_ms: u64) {
        // Use blocking write from async context (safe - we're not blocking the runtime thread)
        *self.current_epoch.write().unwrap() = new_epoch;

        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;

        // FORK-SAFETY: More lenient check for Go-synced timestamps
        // Only override if timestamp is more than 5 seconds in the past
        // This allows for reasonable clock differences between Go and Rust
        let adjusted_timestamp_ms = if new_timestamp_ms < now_ms.saturating_sub(5000) {
            warn!(
                "‚ö†Ô∏è  [EPOCH TIMING] SystemTransactionProvider::update_epoch: new_timestamp_ms {}ms is significantly in the past (now={}ms, diff={}ms). \
                 This may indicate clock sync issues. Using current time to prevent rapid transitions.",
                new_timestamp_ms,
                now_ms,
                now_ms.saturating_sub(new_timestamp_ms)
            );
            now_ms
        } else {
            new_timestamp_ms
        };

        *self.epoch_start_timestamp_ms.write().unwrap() = adjusted_timestamp_ms;
        *self.last_checked_commit_index.write().unwrap() = 0;

        info!(
            "üìÖ SystemTransactionProvider::update_epoch: epoch={}, epoch_start_timestamp_ms={}ms (from new_timestamp_ms={}ms, now={}ms)",
            new_epoch,
            adjusted_timestamp_ms,
            new_timestamp_ms,
            now_ms
        );
    }

    /// Check if epoch transition should be triggered
    fn should_trigger_epoch_change(&self, current_commit_index: u32) -> bool {
        if !self.time_based_enabled {
            tracing::debug!("‚è∞ SystemTransactionProvider: time_based_enabled=false, skipping epoch change check");
            return false;
        }

        // Only check once per commit index to avoid spam
        let last_checked = *self.last_checked_commit_index.read().unwrap();
        if current_commit_index <= last_checked {
            tracing::debug!(
                "‚è∞ SystemTransactionProvider: Already checked commit_index {} (last_checked={}), skipping",
                current_commit_index,
                last_checked
            );
            return false;
        }

        // Check if enough time has elapsed
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
        
        let epoch_start = *self.epoch_start_timestamp_ms.read().unwrap();
        let elapsed_seconds = (now_ms - epoch_start) / 1000;
        
        // Log epoch start timestamp for debugging
        tracing::debug!(
            "‚è∞ SystemTransactionProvider: Time check - epoch_start={}ms, now={}ms, elapsed={}s, duration={}s, remaining={}s",
            epoch_start,
            now_ms,
            elapsed_seconds,
            self.epoch_duration_seconds,
            self.epoch_duration_seconds.saturating_sub(elapsed_seconds)
        );
        
        let should_trigger = elapsed_seconds >= self.epoch_duration_seconds;
        
        // Log every check (throttled by commit index check above)
        if should_trigger {
            info!(
                "‚è∞ SystemTransactionProvider: Epoch change triggered - epoch={}, elapsed={}s, duration={}s, commit_index={}",
                *self.current_epoch.read().unwrap(),
                elapsed_seconds,
                self.epoch_duration_seconds,
                current_commit_index
            );
        } else {
            // Log periodically when close to threshold (every 10 seconds of elapsed time) or when past threshold
            if elapsed_seconds % 10 == 0 || elapsed_seconds >= self.epoch_duration_seconds.saturating_sub(30) {
                // Use info level when past threshold to make it more visible
                if elapsed_seconds >= self.epoch_duration_seconds {
                    tracing::info!(
                        "‚è∞ SystemTransactionProvider: Epoch change check - epoch={}, elapsed={}s, duration={}s, remaining={}s, commit_index={} (PAST THRESHOLD!)",
                        *self.current_epoch.read().unwrap(),
                        elapsed_seconds,
                        self.epoch_duration_seconds,
                        self.epoch_duration_seconds.saturating_sub(elapsed_seconds),
                        current_commit_index
                    );
                } else {
                    tracing::debug!(
                        "‚è∞ SystemTransactionProvider: Epoch change check - epoch={}, elapsed={}s, duration={}s, remaining={}s, commit_index={}",
                        *self.current_epoch.read().unwrap(),
                        elapsed_seconds,
                        self.epoch_duration_seconds,
                        self.epoch_duration_seconds.saturating_sub(elapsed_seconds),
                        current_commit_index
                    );
                }
            }
        }
        
        should_trigger
    }
}

impl SystemTransactionProvider for DefaultSystemTransactionProvider {
    fn get_system_transactions(&self, current_epoch: Epoch, current_commit_index: u32) -> Option<Vec<SystemTransaction>> {
        tracing::debug!(
            "üîç SystemTransactionProvider::get_system_transactions called: epoch={}, commit_index={}, time_based_enabled={}",
            current_epoch,
            current_commit_index,
            self.time_based_enabled
        );

        // Check if epoch transition should be triggered FIRST (before updating last_checked)
        // This ensures we don't skip the check if commit_index hasn't increased
        let should_trigger = self.should_trigger_epoch_change(current_commit_index);
        
        // Only update last_checked if we actually checked (not skipped due to already checked)
        // This allows re-checking if commit_index increases
        {
            let mut last_checked = self.last_checked_commit_index.write().unwrap();
            if current_commit_index > *last_checked {
                *last_checked = current_commit_index;
            }
        }

        if !should_trigger {
            return None;
        }

        // Create EndOfEpoch system transaction
        // CRITICAL FORK-SAFETY: Use deterministic values only
        // - new_epoch: current_epoch + 1 (deterministic)
        // - new_epoch_timestamp_ms: epoch_start + epoch_duration (deterministic, not SystemTime::now())
        // - transition_commit_index: current_commit_index + 10 (deterministic, but may differ between nodes)
        let new_epoch = current_epoch + 1;
        
        // FORK-SAFETY FIX: Use deterministic timestamp calculation
        // Instead of SystemTime::now(), use epoch_start + epoch_duration
        // This ensures all nodes calculate the same timestamp
        // CRITICAL: Always use deterministic calculation to prevent fork
        // If epoch_start is too old, we still use deterministic calculation
        // (rapid transitions are acceptable if epoch_start is incorrect)
        let epoch_start = *self.epoch_start_timestamp_ms.read().unwrap();
        
        // Calculate expected timestamp (deterministic)
        let new_epoch_timestamp_ms = epoch_start + (self.epoch_duration_seconds * 1000);
        
        // Log warning if timestamp seems incorrect (but still use deterministic value)
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
        
        if new_epoch_timestamp_ms < now_ms.saturating_sub(1000) {
            warn!(
                "‚ö†Ô∏è  [FORK-SAFETY] SystemTransactionProvider: Expected timestamp {}ms is in the past (now={}ms, diff={}ms). \
                 Using deterministic timestamp anyway to prevent fork. If epoch_start is incorrect, epoch transitions may be rapid.",
                new_epoch_timestamp_ms,
                now_ms,
                now_ms.saturating_sub(new_epoch_timestamp_ms)
            );
        }

        // FORK-SAFETY WARNING: transition_commit_index may differ between nodes
        // if they have different current_commit_index values.
        // This is acceptable because:
        // 1. System transaction will be included in a committed block
        // 2. All nodes will see the same system transaction in the committed block
        // 3. Transition happens when commit_index >= transition_commit_index (from the committed block)
        // However, to be extra safe, we should use the commit_index from the committed block
        // that contains the system transaction, not the current_commit_index when creating it.
        // 
        // For now, we use current_commit_index + 10, but the actual transition_commit_index
        // should be read from the committed block that contains this system transaction.
        // 
        // SAFETY: Use checked_add to handle overflow explicitly
        // If commit_index is too large (near u32::MAX), we use u32::MAX - 1 to ensure
        // transition can still be triggered, but log a warning.
        // 
        // BUFFER SAFETY: Increased from 10 to configurable buffer (default 100) for high commit rate systems.
        // With commit rate 200 commits/s:
        // - 10 commits = 50ms (not safe for network propagation)
        // - 100 commits = 500ms (safer, allows network delay and processing time)
        let transition_commit_index = current_commit_index
            .checked_add(self.commit_index_buffer)
            .unwrap_or_else(|| {
                warn!(
                    "‚ö†Ô∏è [FORK-SAFETY] commit_index {} qu√° l·ªõn (g·∫ßn u32::MAX), kh√¥ng th·ªÉ c·ªông buffer {}. \
                     S·ª≠ d·ª•ng u32::MAX - 1 l√†m transition_commit_index. \
                     ƒêi·ªÅu n√†y c√≥ th·ªÉ g√¢y v·∫•n ƒë·ªÅ n·∫øu commit_index ti·∫øp t·ª•c tƒÉng. \
                     C√¢n nh·∫Øc reset commit_index ho·∫∑c tƒÉng epoch duration.",
                    current_commit_index, self.commit_index_buffer
                );
                u32::MAX - 1
            });

        info!(
            "üìù SystemTransactionProvider: Creating EndOfEpoch transaction - epoch {} -> {}, commit_index={}, transition_commit_index={}",
            current_epoch,
            new_epoch,
            current_commit_index,
            transition_commit_index
        );

        let system_tx = SystemTransaction::end_of_epoch(
            new_epoch,
            new_epoch_timestamp_ms,
            transition_commit_index,
        );

        Some(vec![system_tx])
    }
}
